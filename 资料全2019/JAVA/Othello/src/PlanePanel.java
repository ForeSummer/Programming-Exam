import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import javax.swing.JOptionPane;
import javax.swing.JPanel;

/**
 *
 * @author asusa
 */
public class PlanePanel extends JPanel {

    /**
	 * 
	 */
	private static final long serialVersionUID = -2265797652205336144L;
	private final int SIZE = 8;
    private ItemButton places[][] = new ItemButton[SIZE][SIZE]; //主棋盘
    private int blackAmount;
    private int whiteAmount;
    private ItemStatus currentPlayer; //当前执子方
    private final String fileName;
    
    /**
     * Creates new form PlanePanel
     */
    public PlanePanel() {
        initComponents();
        GridLayout gl = new GridLayout(SIZE,SIZE);
        gl.setHgap(0);
        gl.setVgap(0);
        fileName = this.getClass().getResource("/").getPath() + "chess.dat";
        this.setLayout(gl);
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0 ; j < SIZE; j++) {
                places[i][j] = new ItemButton(i, j);
                this.add(places[i][j]);
                places[i][j].addActionListener(new ActionListener(){
					public void actionPerformed(ActionEvent e) {
						int x = ((ItemButton)e.getSource()).getXPos();
						int y = ((ItemButton)e.getSource()).getYPos();
						executeClick(x, y);
					}
                	
                });
            }
        }
        resetChess();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 275, Short.MAX_VALUE)
        );
    }
    
    /**
     * 判断游戏是否结束
     * @return true 如果游戏已经无法继续进行，否则返回false
     */
    private boolean isGameOver() {
    	if (currentPlayer == ItemStatus.BLACK) {
    		currentPlayer = ItemStatus.WHITE;
    	} else {
    		currentPlayer = ItemStatus.BLACK;
    	}
    	//换对方，如果能下则返回false
    	for (int i = 0 ; i < SIZE; i++) {
			for (int j = 0 ; j < SIZE; j++) {
				if(canBePlaced(i, j, false)) {
					return false;
				}
			}
		}
    	//再换回本方，如果能下则返回false
    	if (currentPlayer == ItemStatus.BLACK) {
    		currentPlayer = ItemStatus.WHITE;
    	} else {
    		currentPlayer = ItemStatus.BLACK;
    	}
    	for (int i = 0 ; i < SIZE; i++) {
			for (int j = 0 ; j < SIZE; j++) {
				if(canBePlaced(i, j, false)) {
					return false;
				}
			}
		}
    	//否则游戏结束
    	currentPlayer = ItemStatus.EMPTY;
    	return true;
    }
    
    /**
     * 执行下子操作
     * @param x 位置所在列数
     * @param y 位置所在行数
     */
    private void executeClick(int x, int y) {
    	//如果已经结束则直接返回
    	if (currentPlayer == ItemStatus.EMPTY) {
    		JOptionPane.showMessageDialog(null, "游戏已经结束，请按重置键开始");
    		return;
    	} else if (canBePlaced(x, y, true)) {
			for (int i = 0 ; i < SIZE; i++) {
				for (int j = 0 ; j < SIZE; j++) {
					places[i][j].repaint();
				}
			}
			if (isGameOver()) {
				//游戏结束 统计结果
				for (int i = 0 ; i < SIZE; i++) {
					for (int j = 0 ; j < SIZE; j++) {
						if (places[i][j].getItemStatus() == ItemStatus.BLACK) {
							blackAmount++;
						} else if (places[i][j].getItemStatus() == ItemStatus.WHITE) {
							whiteAmount++;
						}
					}
				}
				String msg = "白子: " + whiteAmount + ", 黑子: " + blackAmount + ".";
				if (whiteAmount > blackAmount) {
					msg += " 白方获胜！";
				} else if (whiteAmount < blackAmount) {
					msg += " 黑方获胜！";
				} else {
					msg += " 平局！";
				}
				JOptionPane.showMessageDialog(null, msg);
			}
		} else {
			JOptionPane.showMessageDialog(null, "棋子不能放置在这里");
		}
    }
    
    /**
     * 执行下子操作
     * @param x 位置所在列数
     * @param y 位置所在行数
     * @param isExecute 是否执行棋子反转操作, true 为执行;false为不执行,仅检查
     * 
     * @return true 可以下子，否则返回false
     */
    private boolean canBePlaced(int x, int y, boolean isExecute) {
    	boolean result = false;
    	//必须不为空才可能可以下子
    	if (places[x][y].getItemStatus() == ItemStatus.EMPTY) {
    		ItemStatus eatStatus = ItemStatus.EMPTY;
    		if (currentPlayer == ItemStatus.BLACK) {
    			eatStatus = ItemStatus.WHITE;
    		} else {
    			eatStatus = ItemStatus.BLACK;
    		}
    		//向左搜寻
    		int i = x;
    		int j = y;
    		for (i = x - 1; i >= 0; i--) {
    			if (places[i][y].getItemStatus() != eatStatus) {
    				break;
    			}
    		}
    		if (i >= 0 && i != x - 1 && places[i][y].getItemStatus() == currentPlayer ) {
    			while (i <= x && isExecute) {
    				places[i][y].setItemStatus(currentPlayer);
    				i++;
    			}
    			result = true;
    		}
    		//向右搜寻
    		i = x;
    		j = y;
    		for (i = x + 1; i < SIZE; i++) {
    			if (places[i][y].getItemStatus() != eatStatus) {
    				break;
    			}
    		}
    		if (i != SIZE && i != x + 1 && places[i][y].getItemStatus() == currentPlayer) {
    			while (i >= x && isExecute) {
    				places[i][y].setItemStatus(currentPlayer);
    				i--;
    			}
    			result = true;
    		}
    		//向上搜寻
    		i = x;
    		j = y;
    		for (j = y - 1; j >= 0; j--) {
    			if (places[x][j].getItemStatus() != eatStatus) {
    				break;
    			}
    		}
    		if (j >= 0 && j != y - 1 && places[x][j].getItemStatus() == currentPlayer) {
    			while (j <= y && isExecute) {
    				places[x][j].setItemStatus(currentPlayer);
    				j++;
    			}
    			result = true;
    		}
    		//向下搜寻
    		i = x;
    		j = y;
    		for (j = y + 1; j < SIZE; j++) {
    			if (places[x][j].getItemStatus() != eatStatus) {
    				break;
    			}
    		}
    		if (j != SIZE && j != y + 1 && places[x][j].getItemStatus() == currentPlayer) {
    			while (j >= y && isExecute) {
    				places[x][j].setItemStatus(currentPlayer);
    				j--;
    			}
    			result = true;
    		}
    		//向左上搜寻
    		i = x;
    		j = y;
    		for (j = y - 1, i = x - 1; j >= 0 && i >= 0; i--, j--) {
    			if (places[i][j].getItemStatus() != eatStatus) {
    				break;
    			}
    		}
    		if (i >= 0 && j >= 0 && !(j == y - 1 && i == x - 1) && places[i][j].getItemStatus() == currentPlayer) {
    			while (j <= y && i <= x && isExecute) {
    				places[i][j].setItemStatus(currentPlayer);
    				j++;
    				i++;
    			}
    			result = true;
    		}
    		//向左下搜寻
    		i = x;
    		j = y;
    		for (j = y + 1, i = x - 1; j < SIZE && i >= 0; i--, j++) {
    			if (places[i][j].getItemStatus() != eatStatus) {
    				break;
    			}
    		}
    		if (i >= 0 && j != SIZE && !(j == y + 1 && i == x - 1) && places[i][j].getItemStatus() == currentPlayer) {
    			while (j >= y && i <= x && isExecute) {
    				places[i][j].setItemStatus(currentPlayer);
    				j--;
    				i++;
    			}
    			result = true;
    		}
    		//向右下搜寻
    		i = x;
    		j = y;
    		for (j = y + 1, i = x + 1; j < SIZE && i < SIZE; i++, j++) {
    			if (places[i][j].getItemStatus() != eatStatus) {
    				break;
    			}
    		}
    		if (i != SIZE && j != SIZE && !(j == y + 1 && i == x + 1) && places[i][j].getItemStatus() == currentPlayer) {
    			while (j >= y && i >= x && isExecute) {
    				places[i][j].setItemStatus(currentPlayer);
    				j--;
    				i--;
    			}
    			result = true;
    		}
    		//向右上搜寻
    		i = x;
    		j = y;
    		for (j = y - 1, i = x + 1; j >= 0 && i < SIZE; i++, j--) {
    			if (places[i][j].getItemStatus() != eatStatus) {
    				break;
    			}
    		}
    		if (i != SIZE && j >= 0 && !(j == y - 1 && i == x + 1) && places[i][j].getItemStatus() == currentPlayer) {
    			while (j <= y && i >= x && isExecute) {
    				places[i][j].setItemStatus(currentPlayer);
    				j++;
    				i--;
    			}
    			result = true;
    		}
    	} // End if
    	return result;
    } //End method
    
    /**
     * 重置棋盘为初始状态
     */
    public void resetChess() {
    	blackAmount = 0;
    	whiteAmount = 0;
    	currentPlayer = ItemStatus.BLACK;
    	for (int i = 0 ; i < SIZE; i++) {
			for (int j = 0 ; j < SIZE; j++) {
				places[i][j].setItemStatus(ItemStatus.EMPTY);
			}
		}
    	places[3][3].setItemStatus(ItemStatus.WHITE);
    	places[3][4].setItemStatus(ItemStatus.BLACK);
    	places[4][3].setItemStatus(ItemStatus.BLACK);
    	places[4][4].setItemStatus(ItemStatus.WHITE);
    	for (int i = 0 ; i < SIZE; i++) {
			for (int j = 0 ; j < SIZE; j++) {
				places[i][j].repaint();
			}
		}
    }
    
    /**
     * 将当前棋盘状态写入文件
     */
    public void saveToFile() {
    	try {
			ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(fileName));
			for (int i = 0; i < SIZE; i++) {
				for (int j = 0 ; j < SIZE; j++) {
					out.writeObject(places[i][j].getItemStatus());
				}
			}
			out.writeObject(currentPlayer);
			out.flush();
			out.close();
			JOptionPane.showMessageDialog(null, "保存成功");
		} catch (FileNotFoundException e) {
			JOptionPane.showMessageDialog(null, "文件未找到");
			e.printStackTrace();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(null, "文件写入错误");
			e.printStackTrace();
		}
    }
    
    /**
     * 从文件中读出保存的棋盘状态
     */
    public void readFromFile() {
    	try {
			ObjectInputStream in = new ObjectInputStream(new FileInputStream(fileName));
			//places = (ItemButton[][])(in.readObject());
			for (int i = 0; i < SIZE; i++) {
				for (int j = 0 ; j < SIZE; j++) {
					places[i][j].setItemStatus((ItemStatus) in.readObject());
					places[i][j].repaint();
				}	
			}
			currentPlayer = (ItemStatus) in.readObject();
			in.close();
			JOptionPane.showMessageDialog(null, "读取成功");
    	} catch (FileNotFoundException e) {
			JOptionPane.showMessageDialog(null, "文件未找到");
			e.printStackTrace();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(null, "文件读取错误");
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			JOptionPane.showMessageDialog(null, "类未找到");
			e.printStackTrace();
		}
    }
}
